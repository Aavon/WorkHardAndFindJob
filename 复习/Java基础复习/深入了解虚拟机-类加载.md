**搬运自《Java 虚拟机（第三版）》**

## 类加载中初始化的时机

一个类型从被加载到虚拟机内存中开始，到卸载出内存位置，他的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Uploading）7个阶段。其中验证、准备、解析3个部分统称为连接（linking）。这七个阶段的发生顺序如图所示：

![类的生命周期](https://uploader.shimo.im/f/viftaQqrMpdVV4HU.png!thumbnail)

在图中，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后开始，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。请注意，这里写的是按部就班地“开始”。而不是按部就班地“进行”或按部就班地“完成”，强调这点是因为这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。

关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java 虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，《Java 虚拟机规范》则是严格规定了有且只有**六**种情况必须立即对类进行"初始化"（而加载、验证、准备自然需要在此之前）

* （1）遇到 new、getstatic、putstatic 或 invokestatic 这4条字节码指令时，如果类没有进行过初始化，则需要触发其初始化。生成这4条指令的典型的 Java 代码场景是：
	* 使用 new 关键字实例化对象的时候；
	* 读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；
	* 以及调用一个类的静态方法的时候；
* （2）使用 java.lang.relflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化；
* （3）当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化；
* （4）当虚拟机启动时，用户需要制定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；
* （5）当使用 JDK1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；
* （6）当一个借口中定义了 JDK 8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

对于这六种会触发类型进行初始化的场景，《Java 虚拟机规范》中使用了一个非常强烈的限定语 —— “有且只有”，这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的初始化都不会触发初始化，称为被动引用。下面举三个例子来说明何为被动引用：

（1）被动引用例一：通过子类引用父类的静态字段，不会导致子类的初始化
```
/**
* 通过子类引用父类的静态字段，不会导致子类的初始化
**/
public class SuperClass{
	public static int value = 123;
	static{
		System.out.println("SuperClass init!");
	}
}
public class SubClass{
	static{
		System.out.println("SubClass init!");
	}
}
/**
* 非主动使用类字段演示
*/
public class NotInitialization{
	public static void main(String[] args){
		System.out.println(SubClass.value);    // SuperClass init!
	}
}
```
对于静态字段，只有直接定义这个字段的类才会被初始化,因此通过其子类来引用父类的静态字段，只会触发父类的初始化而不会触发子类的初始化。至于是否要触发子类的加载和验证，在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。对于 Sun HotSpot 虚拟机来说，可通过 -XX:+TraceClassLoading 参数观察到此操作会导致子类的加载（这里的加载指的是将二进制字节流读取到内存中的过程，而不是类加载。前者是后者的一个阶段）。

（2）被动引用例二：通过数组定义来引用类，不会触发此类的初始化
```
/**
* 通过数组定义来引用类，不会触发此类的初始化
**/
public class NotInitialization{
	public static void main(String[] args){
			SuperClass[] sca = new SuperClass[10];
	}
}
```
这边没有输出 "SuperClass init!"，说明没有触发 SuperClass 的初始化阶段。但是这段代码里面触发了另外一个名为 “[Lxxx.xxx.SuperClass”的类的初始化阶段，对于用户代码来说，这并不是一个合法的类名称，它是一个由虚拟机自动生成的、直接继承于 java.lang.Object 的子类，创建动作由字节码指令 newarray 触发。
这个类代表可一个元素类型为 xxx.xxx.SuperClass 的一维数组，数组中应有的属性和方法（用户可直接使用的只有被修饰为 public 的 length 属性和 clone() 方法）都实现在这个类里。 Java 语言中对数组的访问比 C/C++ 更加安全，是因为这个类封装了数组元素的访问方法，而 C/C++ 直接是数组指针的移动。在 Java 语言中，当检查到发生数组越界时，会抛出 ArrayIndexOutOfBoundsException 异常，避免了直接访问造成非法内存访问。

(3)被动引用例三：常量在编一阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化
```
/**
* 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化
**/
public class ConstClass {
	public static final String HELLO_WORLD = "hello world";
	static {
		System.out.println("ConstClass init!");
	}
}
/**
* 非主动使用类字段演示
**/
public class Test{
	public static void main(String[] args) {
		System.out.println(ConstClass.HELLO_WORLD);
	}
}
```
上述代码运行之后，也没有输出 "ConstClass init!"，这是因为虽然在 Java 源码中引用了 ConstClass 类中的常量 HELLO_WORLD，但其实在编译阶段通过常量传播优化，已经将此常量的值 "hello world 存储到了 Test 类的常量池中，以后 Test 对常量 ConstClass.HELLO_WORLD 的引用实际都被转化为 Test 对自身常量池的引用了。也就是说，实际上 Test 的 class 文件中并没有 ConstClass 类的符号引用入口，这两个类在编译成 Class 之后就不存在联系了。

接口的加载过程与类加载过程稍有一些不同，针对接口需要做一些特殊说明：接口也有初始化过程，这点与类是一致的，上面的代码都是用静态语句块`static{}`来输出初始化信息的，而接口中不能使用静态语句块，但编译器仍然会为接口生成 `"<clinit>()"`类构造器，用于初始化接口中所定义的成员变量。接口和类真正有所区别的是前面讲述的 6 种场景中的第三种：当一个类在初始化时，要求其父类全部都已经初始化了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。

-------------------



## 类加载的过程

接下来，详细介绍一下 Java 虚拟机中类加载的全部过程，也就是加载、验证、准备、解析和初始化这 5 个阶段锁执行的具体动作。

### 加载

”加载“是”类加载“（Class Loading）过程的一个阶段，希望读者没有混淆这两个看起来很相似的名词。在加载阶段，虚拟机需要完成以下3件事情：

* 通过一个类的全限定名来获取次类的二进制字节流；
* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
* 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口。

虚拟机规范的这三点要求其实并不算具体，因此虚拟机实现与具体应用的灵活度都是相当大的。例如“通过一个类的全限定名来获取此类的二进制字节流”这条，它没有指明二进制字节流必须得从某个 Class 文件获取，准确地说是根本没有指明要从哪里获取、怎样获取。虚拟机设计团队在加载阶段搭建了一个相当开放的、广阔的舞台，Java 发展历程中，充满创造力的开发人员则在这个舞台上玩出了各种花样，许多举足轻重的 Java 技术都建立在这一基础之上，例如：

* 从 ZIP 包中读取，这很常见，最终成为日后 JAR、EAR、WAR格式的基础；
* 从网络中获取，这种场景最典型的应用就是 APPLET；
* 运行时计算生成，这种场景使用得最多的就是动态代理结束，在`java.lang,reflect.Proxy`中，就是用了 `ProxyGenerator.generateProxyClass`来为特定接口生成形式为`$Proxy`的二进制字节流；
* 从其他文件生成，典型场景是 JSP 应用，即用 JSP 文件生成对应的 Class 类；
* 从数据库中读取，这种场景相对少见些，例如有些中间服务器（如 SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发；
* 可以从加密文件中获取，这是典型的防 Class 文件被反编译的保护措施，通过加载时解密 Class 文件来保障程序运行逻辑不被窥探。

相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确的说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以用用户自定义的类加载器去完成，开发人员可以通过自定义的类加载器去控制字节流的获取方式（即重写一个类加载器的`findCLass()`或`loadClass()`方法）。

对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由 Java 虚拟机直在内存中动态构造出来的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（Element Type，指得是数组去掉所有维度的类型）最终是要靠类加载器去创建，一个数组类（下面简称为 C）创建过程就遵循以下规则：

* 如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型，注意和前面的元素类型区分开来）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组 C 将在加载该组件类型的类加载器的类名称空间上被标识（这点很重要，一个类必须与类加载器一起确定唯一性）；
* 如果数组的组件类型不是引用类型（例如`int[]`数组），Java 虚拟机会把数组 C 标记为与引导类加载器关联；
* 数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为 public，可被所有的类和接口访问到

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个`java.lang.Class`类的对象（并没有明确规定是在 Java 堆中，对于 HotSpot 虚拟机而言，Class 对象比较特殊，它虽然是对象，但是存放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。

加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。



### 验证

验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当做代码运行后不会危害虚拟机自身的安全。

Java 语言本身是相对安全的语言（相对于 C/C++ 而言），使用纯粹的 Java 代码无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果尝试这样做了，编译器将抛出错误、拒绝编译。但前面已经说过，Class 文件并不一定要求用 Java 源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编写来产生 Class 文件。在字节码语言层面，上述 Java 代码无法做到的事情都是可以实现的，至少语义上是可以表达出来的。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。

验证阶段是非常重要的，这个阶段是否严谨，直接决定了 Java 虚拟机是否能承受恶意代码的攻击。从代码量和耗费的执行性能的角度上将，验证阶段的工作量在虚拟机的类加载子系统中占了相当大的比重。但是《Java 虚拟机规范》的早期版本对这个阶段的检验指导还是比较笼统的，规范中仅列举了一些 Class 文件格式中静态和结构化约束，要求虚拟机验证到输入的字节流不符合 Class 文件格式的约束，虚拟机就应抛出一个`java.lang.VerifyError`异常或其子类异常，但具体应当检查哪些方法，如何检查，何时检查，都没有足够具体的要求和明确的说明。直到2011年发布的《Java 虚拟机规范（Java SE 7版）》，大幅度增加了描述验证过程的篇幅（从不到10页增加到130页），这时验证阶段的约束和验证规则才变得具体起来。受篇幅所限，本书无法逐条规则去讲，但从整体上看，验证阶段大致上会完成下面4个阶段的检验动作：**文件格式验证、元数据验证、字节码验证、符号引用验证**。

**1、文件格式验证**

第一阶段要验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：

* 是否以魔数 0xCAFEBABE 开头；
* 主、次版本号是否在当前虚拟机处理范围之内；
* 常量池的常量中是否有不被支持的常量类型（检查常量 tag 标志）；
* 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量；
* CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据；
* Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息；

实际上，第一阶段的验证点还远不止这些，上面这些只是从 HotSpot 虚拟机源码中摘抄的一小部分内容，该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。

**2、元数据验证**

第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求，这个阶段可能包括的验证点如下：

* 这个类是否有父类（除了`java.lang.Object`之外，所有的类都应当有父类）；
* 这个类的父类是否有继承了不允许被继承的类（被 final 修饰的类）；
* 如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法；
* 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的 fianl 字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）；

第二阶段的主要目的是对类的元数据信息进行语义检验，保证不存在不符合 Java 语言规范的元数据信息。

**3、字节码验证**

第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段对类的方法体（Class 文件中的 Code 属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的时间，例如：

* 保证任何时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈防止了一个 int 类型的数据，使用时却按 long 类型来加载如本地变量表中；
* 保证跳转指令不会跳转到方法体以外的字节码指令上；
* 保证方法体中的类型转换是有效地，例如可以把一个子类对象赋值给父类数据类型，这样是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给它毫无继承关系、毫不相关的一个数据类型，则是危险和不合法的；

如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的，但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。即使字节码验证之中进行了大量的检查，也不能保证这一点。这里设计了离散数学中一个很著名的问题 —— “停机问题”（Halting Problem），即不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。在我们讨论字节码检验的上下文语境里，通俗一点的解释是通过程序去校验程序逻辑是无法做到绝对准确地，不可能用程序来准确判定一段程序是否存在 Bug。

由于数据流验证和控制流分析的高复杂性，虚拟机设计团队为了避免过多的时间消耗在字节码验证阶段，在 JDK 6 以后的 Javac 编译器和 Java 虚拟机中进行了一项联合优化，把尽可能多的校验辅助措施挪到 javac 编译器里进行。具体做法是给方法体 Code 属性的属性表中增加了一项名为“StackMapTable”的属性，这项属性描述了方法体中所有的基本块（Basic Block，按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，在字节码验证期间，就不需要根据程序推导这些状态的合法性，只需要检查 StackMapTable 属性中的记录是否合法即可。这样将字节码验证的类型推导转变为类型检查从而节省一些时间。
理论上 StackMapTable 属性也存在错误或被篡改的可能，所以是否有可能在恶意篡改了 Code 属性的同时，也生成相应的 StackMapTable 属性来骗过虚拟机的类型校验则是虚拟机设计者值得思考的问题。

在 JDK 1.6 的 HotSpot 虚拟机中提供了 -XX:-UseSplitVerifier 选项来关闭这项优化，或者使用参数 -XX:+FailOverToOldVerifier 要求在类型验证失败的时候退回到旧的类型推导方式进行校验。而在 JDK 1.7 之后，尽管虚拟机中仍然保留着类型推导验证器的代码，对于主版本号大于 50 的 Class 文件，使用类型检查来完成数据流分析校验则是唯一的选择，不允许再退回到类型推导的校验方式。

**4、符号引用验证**

最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段--解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。本阶段通常需要检验下列内容：

* 符号引用中通过字符串描述的全限定名是否能找到对应的类；
* 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段；
* 符号引用中的类、字段、方法的访问性（`private`、`protected`、`public`、`<package>`）是否可被当前类访问；

符号应用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，Java 虚拟机将会抛出一个`java.lang.IncompatibleClassChangeError`异常的子类，典型的如：`java.lang.IllegalAccessError`、`java.lang.NoSuchFieldError`、`java.lang.NoSuchMethodError`等。

验证阶段对于虚拟机的类加载机制来说，验证阶段是一个非常重要的，但却不是必须要执行的阶段，因为验证阶段只有通过或者不通过的差别，只有通过了验证，其后就对程序运行期没有任何影响了。如果所运行的代码（包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码）都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用 -Xverify:none 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。



### 准备

准备阶段是正式为类中定义的变量（即静态变量，被 static 修饰的变量）分配内存并设置类变量初始值的阶段，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身就是一个逻辑上的区域，在 JDK 7 及之前，HotSpot 使用永久代来实现方法区，实现是完全符合这种逻辑概念的；而在 JDK 8 及以后，类变量则会随着 CLass 对象一起放在 Java 堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了。

关于准备阶段，还有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被 static 修饰的变量）而不包括实例变量，实例变量将在对象实例化时随着对象一起分配在 Java 堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：`public static int value = 123;`，那变量 value 在准备阶段过后的初始值为 0 而不是 123，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 123 的 `putstatic` 指令是程序被编译后，存放于类构造器`<clinit>()`方法之中，所以把 value 赋值为 123 的动作将在初始化阶段才会执行。下表列出了 Java 中所有基本数据类型的零值：

数据类型|零值
--|--
int|0
long|0L
short|(short)0
char|'\u0000'
byte|(byte)0
boolean|false
float|0.0f
double|0.0d
reference|null

上面提到，在“通常情况下”初始值是零值，那相对的会有一些“特殊情况”：如果类字段的字段属性表中存在 ConstantVlaue 属性，那么在准备阶段变量 value 就会被初始化为 ConstantValue 属性所指定的值，假设上面类变量 value 的定义变为`public static final int value = 123;`，编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123。



### 解析

解析阶段是虚拟机将常量池内的符号引用替换成直接引用的过程，符号引用在讲解 Class 文件格式的时候已经多次出现，在 Class 文件中它以 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等类型的常量出现，那解析阶段中所说的直接引用和符号引用又有什么关联呢？

* 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以使任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java 虚拟机规范》的 Class 文件格式中。
* 直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实力上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。

《Java 虚拟机规范》之中并未规定解析发生的具体时间，只要求了在执行`ane-warray`、`checkcast`、`getfield`、`getstatic`、`instanceof`、`invokedynamic`、`invokeinterface`、`invokespecial`、`invokestatic`、`invokevirtual`、`ldc`、`ldc_w`、`ldc2_w`、`multianewarray`、`new`、`putfield` 和 `putstatic` 这 17 个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来自行判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。

类似的，对方法或者字段的访问，也会在解析阶段对它们的可访问性（`public`、`protected`、`private`、`<package>`）进行检查，至于其中的约束规则已经是 Java 语言的基本常识，这里就不再赘述了。

对同一个符号符号引用进行多次解析请求是很常见的事情，除 `invokedynamic` 指令以外，虚拟机实现可以对第一次解析的结果进行缓存，譬如在运行时常量池中记录直接引用，并把常量标识为已解析状态，从而避免解析动作重复进行。无论是否真正执行了多次解析动作，虚拟机都需要保证的是在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解析就应当一直成功；同样的，如果第一次解析失败了，其他指令对这个符号的解析解析请求也应当收到相同的异常，哪怕这个请求的符号在后来已成功加载进 Java 虚拟机内存之中。

不过对于`invokedynamic`指令，上面规则就不成立了。当碰到某个前面已经由`invokedynamic`指令触发过解析的符号引用时，并不意味着这个解析结果对于其他`invokedynamic`指令也同样生效。因为`invokedynamic`指令的目的本来就是用于动态语言支持（ps:`invokedynamic`指令时在 JDK 7 时加入到字节码中的，当时确实只为了做动态语言（如 JRuby、Scala）支持，Java 语言本身并不会用到它。而到了 JDK 8 时代，Java 有了 Lambda 表达式和接口的默认方法，他们在底层调用时就会用到`invokeddynamic`指令，这是再提动态语言支持其实已不完全切合，我们就只把它当个代称吧），它所对应的引用成为“动态调用限定符”（Dynamic Call Site Specifier），这里“动态”的含义就是必须等到程序实际运行到这条指令的时候，解析动作才能进行。相对的，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对应于常量池的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHabdle_info、 CONSTANT_Dyna-mic_info 和 CONSTANT_InvokeDynamic_info 这 8 种常量类型。下面将讲解前面 4 种引用的解析过程，对于后面 4 种，它们都与动态语言支持密切相关，由于 Java 语言是一门静态类型语言，因此在没有介绍 `invokedynamic`指令的语义之前，没有办法将他们和现在的 Java 语言对应上，笔者将在介绍动态语言调用时一起分析讲解。

**1、类或接口的解析**

假设当前代码所处的类为 D ，如果要把一个从未解析过的符号引用 N 解析为一个类或接口 C 的直接引用，那虚拟机完成整个解析的过程需要以下3个步骤：

* 如果 C 不是一个数组类型，那虚拟机将会把代表 N 的全限定名传递给 D 的类加载器去加载这个类 C 。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析动作就宣告失败；
* 如果 C 是一个数组类型，并且数组的元素类型是对象，也就是 N 的描述符会是类似`“Ljava/lang/Integer”`的形式，那将会按照第一点的规则加载数组元素类型。如果 N 的描述符如前面所假设的形式，需要加载的元素类型就是 `“java.lang.Integer”`，接着由虚拟机生成一个代表此数组维度和元素的数组对象；
* 如果上面的步骤没有出现任何异常，那么 C 在虚拟机中实际上已经成为了一个有效的类或者接口了，但在解析完成之前还要进行符号引用验证，确认 D 是否具备对 C 的访问权限。如果发现不具备访问权限，将抛出 `java.lang.IllegalAccessError`异常。

针对上面第三点访问权限验证，在 JDK 9 引入了模块化以后，一个 public 类型也不再意味着程序任何位置都有它的访问权限，我们还需要检查模块间的访问权限。

如果我们说一个 D 拥有 C 的访问权限，那就意味着以下 3 条规则中至少有其中一条成立：

* 被访问类 C 是 public 的，并且与访问类 D 出于同一个模块；
* 被访问类 C 是 public 的，不于访问类 D 出于同一个模块，但是被访问类 C 的模块允许被访问类 D 的模块进行访问；
* 被访问类 C 不是 public 的，但是它与访问类 D 处于同一个包中；

在后续涉及可访问性时，都必须考虑模块间访问权限隔离的约束，即以上列举的 3 条规则，这些内容在后面就不再复述了。

**2、字段解析**

要解析一个未被解析过的字段符号引用，首先将对字段表内 class_index 项中索引的 CONSTANT_Class_info 符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用 C 表示，《Java 虚拟机》规范要求按照如下步骤对 C 进行后续字段的搜索：

* 如果 C 本身就包含了简单名称和字符描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束；
* 否则，如果在 C 中实现了接口，将会按照继承关系从下往上递归所搜各个接口和它的父接口，如果接口中包含了简单名称和字符描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束；
* 否则，如果 C 不是`java.lang.Object`的话，将会按照继承关系从下往上搜索递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束；
* 否则，查找失败，抛出`java.lang.NoSuchFieldError`异常。

如果在查找过程中成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出`java.lang.IllegalAccessError`异常。

以上解析规则能够确保 Java 虚拟机获得字段唯一的解析结果，但在实际应用中，javac 编译器往往会采取比上述规范要求的更加严格一些的约束，譬如有一个同名字段同时出现在某个类的接口和父类中，或者同时在自己或父类的多个接口中出现，按照解析规则仍是可以确定唯一的访问字段，但 javac 编译器就可能直接拒绝其编译为 Class 文件。在下面代码中，如果注释了 Sub 类中的`public static int A=4;`，接口与父类同时存在字段 A ，那编译器将提示“ The field Sub.A is ambiguous”，并且拒绝编译这段代码。
```
pakage org.fenixsoft.classloading;
public class FieldResolution{
	interface Interface0{
		int A = 0;
	}
	interface Interface1 extends Interface0{
		int A = 1;
	}
	interface Interface2{
		int A = 2;
	}
	static class Parent implements Interface1{
		public static int A = 3;
	}
	static class Sub extend Parent implements Interface2{
		public static int A = 4;
	}
	public static void main(String[] args){
		System.out.println(Sub.A);
	}
}
```

**3、方法解析**

方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的 class_index 项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用 C 表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索：

* 由于 Class 文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类方法表中发现 class_index 中索引的 C 是个接口，那就直接抛出`java.lang.IncompatibleClassChangeError`异常；
* 如果通过了第一步，在类 C 中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束；
* 否则，在类 C 的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束；
* 否则，在类 C 实现的接口列表及他们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类 C 是一个抽象类，这时查找结束，抛出`java.lang.AbstractMethodError`异常；
* 否则，宣告方法查找失败，抛出`java.lang.NoSuchMethodError`。

最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出`java.lang.IllegalAccessError`异常。

**4、接口方法解析**

接口方法也需要先解析出接口方法表的 class_index 项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用 C 表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：

* 与类方法解析相反，如果在接口方发表中发现 class_index 中的索引 C 是个类而是不是接口，那就直接抛出 `java.lang.IncompatibleClassChangeError`异常；
* 否则，在接口 C 中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束；
* 否则，在接口 C 的父接口中递归查找，直到 `java.lang.Object`类（接口方法的查找范围也会包括 Object 类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束；
* 对于规则 3，由于 Java 的接口允许多重继承，如果 C 的不同父接口存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，《Java 虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法。但与之前字段查找类似的，不同发行商实现的 javac 编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性；
* 否则，宣告方法查找失败，抛出 `java.lang.NoSuchMethodError`异常。

在 JDK 9 之前，Java 接口中的所有方法都默认是 public 的，也没有模块化的约束访问，所以不存在访问权限的问题，接口方法的符号解析就不可能抛出`java.lang.IllegalAccessError`异常。但在 JDK 9 中增加了接口的静态私有方法，也有了模块化的访问约束，所以从 JDK 9 起，接口方法的访问也完全有可能因访问控制权限而出现`java.lang.IllegalAccessError`异常。



### 初始化

类初始化阶段是类加载过程的最后一步，之前介绍的几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。直到初始化阶段，才真正开始执行类中定义的 Java 程序代码，将主导权移交给应用程序。

在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器`<clinit>()`方法的过程。`<clinit>()`并不是程序员在 Java 代码中直接编写的方法，它是 Javac 编译器的自动生成物，但我们非常有必要了解这个方法具体是如何产生的，以及`<clinit>()`方法执行过程中可能会影响程序运行行为的细节，这部分相对更贴近普通的程序开发人员。

* `<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并而成的，编译器收集的顺序是语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问，如下面代码所示：

```
public class Test{
	static{
		i = 0;    //给变量赋值可以正常编译
		System.out.println(i);    //这句编译器会提示“非法向前引用”
	}
	static int i = 1;
}
```

* `<clinit>()`方法与类的构造函数（或者说实例构造器`<init>()`方法）不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的`<clinit>()`方法执行之前，父类的`<clinit>()`方法已经执行完毕。因此在虚拟机第一个被执行的`<clinit>()`方法的类肯定是`java.lang.Object`。

* 由于父类的`<clinit>()`方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作，如下面代码中，字段 B 的值将会是2而不是1。

```
static class Parent{
	public static int A = 1;
	static{
		A = 2;
	}
}

static class Sub extends Parent{
	public static int B = A;
}

public static void main(String[] args){
	System.out.println(Sub.B);
}
```

* `<clinit>()`方法糴类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法。

* 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成`<clinit>()`方法。但接口与类不同的是，执行接口的`<clinit>()`方法不需要先执行父接口的`<clinit>()`方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的`<clinit>()`方法。

* 虚拟机会保证一个类的`<clinit>()`在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的`<clinit>()`方法，其他线程都需要阻塞等待，直到活动线程执行`<clinit>()`方法完毕。如果在一个类的`<clinit>()`方法中有耗时很长的操作，就可能造成多个线程（原书是进程？？？）阻塞，在实际应用中这种阻塞往往是很隐蔽的。下面代码演示了这种场景：
```
static class DeadLoopClass{
	static{
		/*如果不加上这个if语句，编译器将提示“Initializer does not complete normally”并拒绝编译*/
		if(true){
			System.out.println(Thread.currentThread() + "init DeadLoopClass");
			while(true){
			}
		}
	}
}
public static void main(String[] args){
	Runnable script = new Runnable(){
		public void run(){
			System.out.println(Thread.currentThread() + "start");
			DeadLoopClass dlc = new DeadLoopClass();
			System.out.println(Thread.currentThread() + "run over");
		}
	};
	Thread thread1 = new Thread(script);
	Thread thread2 = new Thread(script);
	thread1.start();
	thread2.start();
}

```
运行结果如下，即一条线程在死循环以模拟长时间操作，另外一条线程在阻塞等待：
```
Thread[Thread-0,5,main] start
Thread[Thread-1,5,main] start
Thread[Thread-0,5,main] init DeadLoopClass
```

