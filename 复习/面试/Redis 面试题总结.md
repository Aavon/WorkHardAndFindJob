# Redis 面试题总结

## 1. 什么是 redis？简述它的优缺点？

Redis的全程：Remote Dictionary Server，本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。因为是纯内存操作，redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。

Redis 的出色性能不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个 value 的最大限制是 1 GB，不像 memecached 只能保存 1 MB 的数据，因此 Redis 可以用来实现很多有用的功能。比如说用它的 List 来做 FIFO 双向链表，实现一个轻量级的高性能消息队列服务，用它的 Set 可以做高性能的 tag 系统等等。

另外 redis 也可以对存入的 Key-Value 设置 expire 时间，因此也可以被当做一个功能加强版的 memcached 来用。Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。



## 2. Redis 支持的 Java 客户端有哪些？官方推荐用哪个？

Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。



## 3. Redis 与 Memcached 相比有哪些优势？

* memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型。
* redis 的速度比 memcached 快很多。
* redis 可以持久化其数据。

![Redis 与 Memcached 区别](https://uploader.shimo.im/f/25eUxdLFfATkffAK.png!thumbnail)



## 4. Redis 支持哪几种数据类型？并简单介绍一下？

String（字符串）、Hash（哈希表）、List（列表）、Set（集合）、Zset（sorted set：有序集合）

### String（字符串）

String是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。

String类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。

String类型是Redis最基本的数据类型，一个键最大能存储512MB。

>一个键能存512M，但是取出来的时候就要注意了。如果存的value过大，却用String接收的话，就会抛异常了。我们就出现过线上问题~

### Hash（哈希表）

Redis hash 是一个键值对集合。

Redis hash 是一个 String 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。每个 hash 可以存储 2^32 - 1键值对（40多亿）。

### List（列表）

Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。

列表最多可存储 2^32 - 1元素 (4294967295, 每个列表可存储40多亿)。

### Set（集合）

Redis的Set是string类型的无序集合。

集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。

sadd 命令:添加一个 String 元素到 key 对应的 set 集合中，成功返回 1,如果元素以及在集合中返回 0,key 对应的 set 不存在返回错误。

### Zset（有序集合）

Redis zset 和set一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。

zset的成员是唯一的,但分数(score)却可以重复。

zadd命令：添加元素到集合，元素在集合中存在则更新对应score.

**Zset 的实现**

[博客](https://www.cnblogs.com/yuanfang0903/p/12165394.html)



## 5. 怎么理解 Redis 事务？相关事务命令有哪些？并介绍一下

事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行，事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

命令：`MULTI`、`EXEC`、`DISCARD`、`WATCH`、`UNWATCH`.

* DISCARD
取消事务，放弃执行事务块内的所有命令。

* EXEC
执行所有事务块内的命令。

* MULTI
标记一个事务块的开始。

* UNWATCH
取消 WATCH 命令对所有 key 的监视。

* WATCH key [key …]
监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。

在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。在 Redis中，事务总是具有原子性（Atomicity)、一致性(Consistency)和隔离性（Isolation），并且当 Redis 运行在某种特定的持久化模式下时，事务也具有持久性（Durability）。

值得一提的是，在事务开始之后、执行之前，所有操作会放到一个队列中，直到真正执行才会生效。如果当中出现了错误，在 2.6.5 以前会执行正确的命令抛弃错误的命令，2.6.5 以后则会把整个事务抛弃。

在 Redis 中事务没有回滚机制，原因主要有两点：

* redis命令只有两个错误会出现，一个为错误的语法结构，一个为对数据类型使用错误的方法处理。这两个问题在开发环境自测的时候就能够发现。
* 回滚操作过于麻烦，为了保证 redis 的快速性，抛弃了回滚



## 6. 为什么要用 redis 而不用 map/guava 做缓存?

缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。

使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached 服务的高可用，整个程序架构上较为复杂。



## 7. redis 设置过期时间

Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。

我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。

如果假设你设置了一批 key 只能存活 1 个小时，那么接下来 1 小时后，redis 是怎么对这批 key 进行删除的？（注意：这里仅仅讲的是设置过期时间中的过期 key 删除方式！）

**定期删除** + **惰性删除**。

通过名字大概就能猜出这两个删除方式的意思了。

### 定期删除（主动删除）

redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定期遍历这个字典来删除到期的 key。

**策略**

Redis 默认会每秒进行十次过期扫描（100ms一次），过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略。

* 从过期字典中随机 xx 个 key；
* 删除这 xx 个 key 中已经过期的 key；
* 如果过期的 key 比率超过 1/4，那就重复步骤 1；

### 惰性删除（被动删除）

除了定期遍历之外，它还会使用惰性策略来删除过期的 key，所谓惰性策略就是在客户端访问这个 key 的时候，redis 对 key 的过期时间进行检查，如果过期了就立即删除，不会给你返回任何东西。

但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？

个人想法是，可以通过记录上一次主动删除过程中删除 key 的数量或者说过去一段时间的平均值，来预判过期 key 的数量，动态修改比值。



## 8. （接上文）内存清理策略

redis 配置文件 redis.conf 中有相关注释，大家可以自行查阅或者通过这个网址查看：
http://download.redis.io/redis-stable/redis.conf

* 被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key
* 主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批已过期的key
* 当前已用内存超过maxmemory限定时，触发主动清理策略

主动清理策略有以下 6 种：

* volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
* volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
* volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
* allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
* allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
* no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错



## 9. 说一说Redis 内存淘汰机制（MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？）

主动清理策略有以下 6 种：

* volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
* volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
* volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
* allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
* allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
* no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错



## 10. 如何解决 Redis 的并发竞争 Key 问题？

所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！

### 方案 1：分布式锁

如果对 key 的操作不要求顺序，那么准备一个分布式锁。

### 方案 2：分布式锁 + 时间版本

通过 value 的时间版本比较来决定自己是否可以 set

### 方案 3：消息队列

将并行操作串行化



## 11. Redis 为什么是单线程的？（请把问题区别于“Redis 为什么这么快”）

官方 FAQ 表示，因为 Redis 是基于内存的操作，CPU不是Redis的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。对于并发的场景，Redis 利用队列技术将并发访问变为串行访问。



## 12. Redis 为什么这么快？

主要有以下几点：

* 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)。

* 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的。

* 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。

* 使用多路I/O复用模型，非阻塞IO。（这个涉及到操作系统的内容了，我不太懂，反正就是一种单线程监听多个网络请求的技术）

* 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

  


## 13. 说一说 redis 的持久化机制？

Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当 Redis 重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。

实现：单独创建 fork() 一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。

* RDB是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。（ 快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。）
* AOF：Redis会将每一个收到的写命令都通过Write函数追加到文件最后，类似于MySQL的binlog。当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。

当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。



## 14. 热点数据和冷数据是什么?

热点数据，缓存才有价值

对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。

对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存

对于上面两个例子，寿星列表、导航信息都存在一个特点，就是信息修改频率不高，读取通常非常高的场景。

数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。

那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。



## 15. 简单说一说缓存雪崩以及解决办法？

缓存雪崩：大面积的缓存在同一时间失效，导致所有请求都去查数据库，使得数据库 CPU 和内存负载过高

解决方案：

* 保证缓存层服务的高可用性，比如主从、分布式缓存、尽快补上机器
* 在缓存失效后通过加锁或者队列的方式来限流并降级，防止数据库崩坏
* 将持久化保存的数据快速恢复，并在大并发访问前对数据进行预热，以及设置不同的过期时间



## 16. 简单说一说缓存穿透以及解决办法？

缓存穿透说简单点就是**大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层**。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。

解决方案：

* 布隆过滤器，用来判断请求的 key 是否有可能存在，不存在就直接过滤
* 缓存空值。当 key 不存在给他设定一个空值



## 17. 简单说一说缓存预热？

缓存预热就是系统上线后，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

解决方案：

* 直接写个缓存刷新页面，上线时手工操作下；
* 数据量不大，可以在项目启动的时候自动进行加载；
* 定时刷新缓存；
* 抓包，通过消息队列 + flink 的流数据处理进行分析



## 18. 简单说一说缓存降级？

当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。

降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。

以参考日志级别设置预案：

* 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；
* 警告：有些服务在一段时间内成功率有波动（如在 `95~100%` 之间），可以自动降级或人工降级，并发送告警；
* 错误：比如可用率低于 `90%`，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；
* 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。

服务降级的目的，是为了防止 Redis 服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis 出现问题，不去数据库查询，而是直接返回默认值给用户。



## 19. Redis 常见性能问题和解决方案？

* Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件
* 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次
* 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内
* 尽量避免在压力很大的主库上增加从库
* 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3…



## 20. Redis如何实现分布式锁？

* 根据 lockKey 区进行 setnx（set_not_exist，如果 key 值为空，则正常设置，返回 1，否则不会进行设置并返回 0）操作，如果设置成功，表示已经获得锁，否则并没有获取锁。
* 如果没有获得锁，去 Redis 上拿到该 key 对应的值，在该 key 上我们存储一个时间戳（用毫秒表示，t1），为了避免死锁以及其他客户端占用该锁超过一定时间（5 秒），使用该客户端当前时间戳，与存储的时间戳作比较。
* 如果没有超过该 key 的使用时限，返回 false，表示其他人正在占用该 key，不能强制使用；如果已经超过时限，那我们就可以进行解锁，使用我们的时间戳来代替该字段的值。
* 但是如果在 setnx 失败后，get 该值却无法拿到该字段时，说明操作之前该锁已经被释放，这个时候，最好的办法就是重新执行一遍 setnx 方法来获取其值以获得该锁。

![Redis 分布式锁流程图](https://uploader.shimo.im/f/3c065jk7yNWi4DZO.png!thumbnail)

但是这种方法不是很好，时间戳就必须要求子系统们必须时间一致。可以看下面博客怎么实现分布式锁

[Redis分布式锁的正确实现方式](https://www.cnblogs.com/moxiaotao/p/10829799.html)



## 21. 如何保证缓存与数据库双写时的数据一致性？

你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？

一般来说，就是如果你的系统不是严格要求缓存 + 数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况

串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。

还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是先更新数据库，然后再删除缓存。

这种情况不存在并发问题么？

不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生

* 缓存刚好失效
* 请求A查询数据库，得一个旧值
* 请求B将新值写入数据库
* 请求B删除缓存
* 请求A将查到的旧值写入缓存

ok，如果发生上述情况，确实是会发生脏数据。

然而，发生这种情况的概率又有多少呢？

发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。

如何解决上述并发问题？

首先，给缓存设有效时间是一种方案。其次，采用异步延时删除策略，保证读请求完成以后，再进行删除操作。



## 22. 是否使用过Redis集群，集群的原理是什么？

Redis Sentinal 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master，继续提供服务。
Redis Cluster 着眼于扩展性，在单个 redis 内存不足时，使用 Cluster 进行分片存储。

Slot：插槽，可以存储两个数值的一个变量这个变量的取值范围是：0-16383。
Cluster：集群管理者，使集群对外暴漏的是一个整体。
redis cluster：采用虚拟分区的方式，将整个集群看成一个整体，然后分成16384个槽位。然后再将16484个槽位分别分配给集群的各个节点，然后各个节点各自负责一部分槽位。

![Redis 集群](https://uploader.shimo.im/f/7zCzw5rrdLVePXRF.png!thumbnail)

**原理**：
节点1负责 0-5000之间的槽位，节点2负责5001-10000之间的槽位，节点3负责10001-16383之间的槽位。
k-v键值对数据只会和槽位相关，与物理机器无关。通过crc16算法计算出 k 对应的整数值（有点类似hash），然后对算出的整数值%16384取模，计算出k-v对应在哪个槽位上，然后再根据槽位与机器节点的映射关系，存储到相应的节点上去（其实这个槽位就是一致性 hash 的实现）。取的时候，也是相应的过程所以整个集群协同一致对外，给client看到的视图就是完整的数据集。



## 23. redis 事务的了解CAS(check-and-set 操作实现乐观锁 )?

和众多其它数据库一样，Redis作为NoSQL数据库也同样提供了事务机制。在Redis中，MULTI/EXEC/DISCARD/WATCH这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出Redis中事务的实现特征：

* 在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。
* 和关系型数据库中的事务相比，在Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。（2.6.5 以后会直接抛弃事务）
* 我们可以通过MULTI命令开启一个事务，有关系型数据库开发经验的人可以将其理解为"BEGIN TRANSACTION"语句。在该语句之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行EXEC/DISCARD命令来提交/回滚该事务内的所有操作。这两个Redis命令可被视为等同于关系型数据库中的COMMIT/ROLLBACK语句。
* 在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行。
* 当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。
Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。



## 24. WATCH命令和基于 CAS 的乐观锁？

在Redis的事务中，WATCH 命令可用于提供 CAS(check-and-set)功能。假设我们通过 WATCH 命令在事务执行之前监控了多个 Keys，倘若在 WATCH 之后有任何 Key 的值发生了变化，EXEC 命令执行的事务都将被放弃，同时返回 Null multi-bulk 应答以通知调用者事务执行失败。例如，我们再次假设 Redis 中并未提供 incr 命令来完成键值的原子性递增，如果要实现该功能，我们只能自行编写相应的代码。其伪码如下：

```
　　val = GET mykey
　　val = val + 1
　　SET mykey $val
```

以上代码只有在单连接的情况下才可以保证执行结果是正确的，因为如果在同一时刻有多个客户端在同时执行该段代码，那么就会出现多线程程序中经常出现的一种错误场景--竞态争用(race condition)。比如，客户端A和B都在同一时刻读取了 mykey 的原有值，假设该值为 10，此后两个客户端又均将该值加一后 set 回 Redis 服务器，这样就会导致 mykey 的结果为 11，而不是我们认为的 12。为了解决类似的问题，我们需要借助 WATCH 命令的帮助，见如下代码：

```
　　WATCH mykey
　　val = GET mykey
　　val = val + 1
　　MULTI
　　SET mykey $val
　　EXEC
```

和此前代码不同的是，新代码在获取 mykey 的值之前先通过 WATCH 命令监控了该键，此后又将 set 命令包围在事务中，这样就可以有效的保证每个连接在执行 EXEC 之前，如果当前连接获取的 mykey 的值被其它连接的客户端修改，那么当前连接的 EXEC 命令将执行失败。这样调用者在判断返回值后就可以获悉 val 是否被重新设置成功。



## 25. redis 最适合的场景有哪些?

Redis 最适合所有数据 in-momory 的场景，虽然 Redis 也提供持久化功能，但实际更多的是一个 disk-backed 的功能，跟传统意义上的持久化有比较大的差别，那么可能大家就会有疑问，似乎 Redis 更像一个加强版的 Memcached，那么何时使用 Memcached，何时使用 Redis 呢?

如果简单地比较 Redis 与 Memcached 的区别，大多数都会得到以下观点：

* Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。
* Redis 支持数据的备份，即 master-slave 模式的数据备份。
* Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。

### (1) 会话缓存（Session Cache）

最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？

幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为人知的商业平台 Magento 也提供 Redis 的插件。

### (2) 全页缓存（FPC）

除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。

再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。
此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。

### (3) 队列

Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop 操作。

如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用 Redis 作为 broker，你可以从这里去查看。

### (4) 排行榜/计数器
Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。
所以，我们要从排序集合中获取到排名最靠前的 10 个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：
当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：
```
ZRANGE user_scores 0 10 WITHSCORES
```
Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可以在这里看到。

### (5) 发布/订阅

最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用 Redis 的发布/订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。
Redis 提供的所有特性中，我感觉这个是喜欢的人最少的一个，虽然它为用户提供如果此多功能。


## 26. 说说 Redis 哈希槽的概念？

Redis集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。

但是我们可以自己通过代码实现。



## 27. Redis 集群方案什么情况下会导致整个集群不可用？

有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。



