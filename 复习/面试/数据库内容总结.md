## 数据库内容总结

在很多篇面经中都看到了数据库相关知识点，很多内容一知半解，看到别人能讲到 MVCC 很是羡慕，于是在此整理一下常问的问题，给自己扫一下盲。

### 一、索引相关
#### 1.什么是聚簇索引和非聚簇索引？

首先，聚簇索引和非聚簇索引指的是数据的物理存储方式，他们的区别在于根据索引查到的是直接的数据还是主键值，跟索引的数据结构、是否是 B+ 树没有关系。

##### 聚簇索引

聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。
InnoDB 通过主键聚集数据，如果没有定义主键，InnoDB 会选择非空的唯一索引代替。如果没有这样的索引，InnoDB 会隐式的定义一个主键来作为聚簇索引。
聚簇索引的优缺点
优点：

* (1) 数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快

* (2) 聚簇索引对于主键的排序查找和范围查找速度非常快

  缺点：

* (1) 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键

* (2) 更新主键的代价很高，因为将会导致被更新的行移动。因此，对于 InnoDB 表，我们一般定义主键为不可更新。

* (3) 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。

##### 非聚簇索引

在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的 Page Directory 找到数据行。
InnoDB 辅助索引的叶子节点并不包含行记录的全部数据，叶子节点除了包含键值外，还包含了相应行数据的聚簇索引键。
辅助索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个辅助索引。在 InnoDB 中有时也称辅助索引为二级索引。



#### 2.聚簇索引和非聚簇索引用在什么地方？

一般我们提到聚簇索引和非聚簇索引，都是在 InnoDB 和 MyISAM 的比较中。 InnoDB 使用聚簇索引构建了主键的 B+ 树，其他辅助索引叶子节点找到的都是主键的值，然后通过主键去寻找聚簇索引的叶子节点，拿到具体的行数据。而 MyISAM 则都是非聚簇索引，即使是二级索引叶子节点存储的也是地址，跟利用主键构造的索引是一样的。

如下图所示，可以看到在 InnoDB 中，所有辅助键索引在查找完成之后得到的都是主键的值，还需要再次通过主键索引去查找具体的行数据（即覆盖索引，一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取，减少了 IO 操作）；而在 MyISAM 中，辅助键索引能直接找到具体的行数据的地址，这就避免了再一次的主键索引，因此光是从这方面来说，MyISAM 的查询效率应该是比 InnoDB 要高的，但是加上 IO 操作的时间就不好说了。

![聚簇索引和聚簇索引](https://uploader.shimo.im/f/TlU3LnmhzbtUct29.png!thumbnail)



#### 3.主键索引和辅助键索引、一级索引和二级索引等概念的区别

**聚簇索引和非聚簇索引**
聚簇索引和非聚簇索引是从物理存储方面进行划分的。
聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致，聚集索引表记录的排列顺序与索引的排列顺序一致，优点是查询速度快，因为一旦
具有第一个索引值的纪录被找到，具有连续索引值的记录也一定物理的紧跟其后。
聚集索引的缺点是对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排，
降低了执行速度。非聚集索引指定了表中记录的逻辑顺序，但记录的物理顺序和索引的顺序不一致，聚集索引和非聚集索引都采用了B+树的结构，但非聚集索引的叶子层并不与实际的存储空间直接挂钩。

**主键索引和辅助键索引**
主键索引对主键构建的索引，是在我们创建表激活后由系统自动创建的。辅助键索引是对非主键的列构建的索引，由我们自己创建。

**一级索引和二级索引**
查了一圈没有看到一级索引的字眼，所以一级索引这个称呼应该是不 正式的，我们所谓的一级索引其实就是聚簇索引（聚簇索引必定是由主键构成的），因为其他索引都得重新走一遍聚簇索引才能拿到值。二级索引是和一级索引相比较的概念，是辅助键索引有时候的称呼（存在聚簇索引就可以称呼辅助键索引为二级索引），称呼为二级索引是因为在走完辅助键索引之后，还得再走一遍聚簇索引才能取到值，所以辅助键索引地位较低。

**单列索引和联合索引**
单列索引就是对单独一个列建立的索引。联合索引是对多个字段同时建立的索引，具体看[联合索引的详情](#union_index)

**一般(normal)索引和唯一性(unique)索引**
一般索引就是普通索引，这没什么好讲的，而唯一性索引则是在普通索引的基础上加上了索引列的唯一性的约束（允许有空值），如果是联合索引，那么索引列的组合必须唯一。比如说，一般索引举个例子，人名，国家允许多个相同人名的人出现；唯一性索引，举个例子，身份证，不允许重复，或者说你们班级里有两个同名的人，一男一女，那么（名字 + 性别）也能作为唯一性索引，反正就是必须唯一。

**B+ 树索引、哈希（hash）索引、全文（full-text）索引、空间数据（R-tree）索引**
这是从索引的逻辑结构进行划分的。[参考博客](https://www.cnblogs.com/JasonCeng/p/12044109.html)
**B+ 树索引**是将列进行树化，变成一颗 B+ 树。InnoDB 中的聚簇索引就是 B+ 树。
**哈希索引**（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，并在哈希表中保存指向每个数据行的指针。

![哈希索引图解](https://uploader.shimo.im/f/hlPWdkOrVtWizrZC.png!thumbnail)

**全文索引**主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。
**R-tree 索引**MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，这类索引无须前缀索引。空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。必须使用MySQL的GIS相关函数如MBRCONTAINS()等来维护数据。MySQL的GIS支持并不完善，所以大部分人都不会使用这个特性。



#### <a id="union_index">4.联合索引的详情</a>

在很多篇面经中都讲到了联合索引的知识，这边我们再梳理一下。
对于两个或两个以上列的索引称为复合索引。在创建了联合索引之后，我们进行多个字段的查询时可以只用索引中的一部分，但只能是最左侧部分，例如索引是 index(a,b,c) ，那么该索引可以支持 a | a,b | a,b,c 三种组合进行查找，但不支持 b,c 进行查找（最左原则），支持 a,c 但是实际上只用到了 a 索引。
联合索引常常和[优化索引](#index_optimize)一起问到。



#### 5.索引的底层结构

前面我们讲了这些个索引的作用和区别，现在我们来讲讲索引的底层结构，为什么索引能优化查询。
如果没有索引，我们查询数据的时候，没有任何工具可以依靠，那么只能通过**全表遍历**来查询。
对于有序的数据来说，可以对全表遍历进行优化，通过二分查找的方式进行查询。但是这样的查询方法依旧不够好，只能用于有序数据，其他的就不行。
**哈希索引**通过计算键的 hash 值，然后在相应的物理空间存储该行数据的地址。哈希索引能以 O(1) 时间进行查找，但是失去了有序性：
* 无法用于排序与分组；
* 只支持精确查找，无法用于部分查找和范围查找。
InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

**B+ 树索引**是通过将键构成一棵 B+ 树进行查找的。关于 B+ 树的内容可以自己搜索。InnoDB 的主键索引就是 B+ 树索引。InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。

**全文索引**MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。



#### <a id="index_optimize">6.如何优化索引</a>

* 尽量选择惟一性索引；
* 为经常需要排序、分组和联合操作的字段建立索引；
* 为常作为查询条件的字段建立索引；
* 限制索引的数目，索引越多，更新和插入的效率越低；
* 尽量使用数据量少的索引；
* 组合索引中的尽量把能过滤掉更多数据的字段放在前面，把最经常使用的字段放在前面（最左原则）；
* 尽量使用前缀来索引，针对长文本，TEXT等类型；
* 删除不再使用或者很少使用的索引；
* 数据是动态变化中的，索引的使用也需要根据数据的变化而变化。



---------------



### 二、锁相关
#### 1.什么是锁？MySQL 中提供了几类锁？

锁是多用户竞争的一种临界资源，是实现数据库并发控制的重要手段，可以保证数据库在多人同时操作时能够正常运行。MySQL 提供了全局锁、行级锁、表级锁。其中 InnoDB 支持表级锁和行级锁，MyISAM 只支持表级锁。



#### 2.锁的划分

* 按照锁的粒度划分：行锁、表锁、页级索、全局锁
* 按照锁的使用方式划分：共享锁、互斥锁（悲观锁的一种实现）
* 还有两种思想上的锁：悲观锁、乐观锁
* 在读写锁的基础上引入的意向锁，实现锁的细粒度化
* InnoDB中有几种行级锁类型：Record Lock、Gap Lock、Next-key Lock
	* Record Lock：在索引记录上加锁
	* Gap Lock：间隙锁
	* Next-key Lock：Record Lock+Gap Lock
	

(1) 行锁、表锁、全局锁：行锁是对行数据进行加锁，表锁是对整张表进行加锁，页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁，一次锁定相邻的一组记录，而全局锁是对整个数据库进行加锁，典型的使用场景就是全库逻辑备份。

(2) 共享锁、互斥锁:互斥锁（Exclusive），简写为 X 锁，又称写锁。共享锁（Shared），简写为 S 锁，又称读锁。
* 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
* 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。


(3) 悲观锁、乐观锁
锁|概述|使用场景|样例
---|---|---|---
**悲观锁**|悲观锁对数据被外界修改持保守态度（悲观），因此在整个数据处理过程中，将数据出于锁定状态，而别的任务出于被阻塞的状态；|写多读少，保证写操作时的数据安全|1、JVM中的synchronized和Lock；2、分布式环境基于数据库行锁、页锁、表锁、共享锁（读锁）、排它锁（写锁）；3、基于zookeeper、Redis 的分布式锁
**乐观锁**|乐观锁认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的重提与否进行检测，如果发现冲突了，程序自动去重试（实现通常用“版本号”）|读多写少，提高系统吞吐|1、JDK并发包中的原子类；2、数据库乐观锁、缓存乐观锁

(4) 意向锁
使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。
在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。
意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：
* 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
* 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。
下图是意向锁之间的兼容关系

![意向锁兼容关系](https://uploader.shimo.im/f/BZdwPNnrxYEESY18.png!thumbnail)

解释如下：
* 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；
* 这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）

(5) Record Lock、Gap Lock、Next-key Lock
首先，我们要明确这三者都是 InnoDB 中行级锁的范围，并且这三种锁作用的基础和对象都是索引。
* 行锁（Record Lock），在单条索引记录上加锁，record lock 锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。所以说当一条sql没有走任何索引时，那么将会在每一条聚集索引后面加X锁，这个类似于表锁，但原理上和表锁应该是完全不同的；
* 间隙锁（Gap Lock），在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。gap lock的机制主要是解决可重复读模式下的幻读问题；
* Next-Key Lock，是行锁和间隙锁的组合使用，默认情况下，InnoDB工作在可重复读隔离级别下，并且会以 Next-Key Lock 的方式对数据行进行加锁，这样可以有效防止幻读的发生。当 InnoDB 扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。



#### 3.什么是死锁？

死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的过程称为死锁。
* MyISAM 不会出现死锁，因为 MyISAM 总是一次获得所需要的全部锁，要么全部满足，要么全等待；
* InnoDB 除了单 SQL 事务，锁是逐步获得的，因此可能出现死锁。一般 InnoDB 能自动检测死锁，并使一个较简单的事务回退并释放锁，另一个事务获得锁，继续完成事务。


#### 4.如何处理死锁

对待死锁常见的两种策略：
* 通过 innodblockwait_timeout 来设置超时时间，一直等待直到超时；
* 发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其它事务继续执行。



#### 5.如何判断死锁

(1) 超时法
如果某个事物的等待时间超过指定时限，则判定为出现死锁

(2) 等待图法
等待图法指的是如果事务等待图中出现了回路，则判断出现了死锁



#### 6.如何查看死锁？

* 使用命令 show engine innodb status 查看最近的一次死锁。
* InnoDB Lock Monitor 打开锁监控，每 15s 输出一次日志。使用完毕后建议关闭，否则会影响数据库性能。



#### 7.如何避免死锁？

(1) 按同一顺序访问对象
如果所有并发事务按同一顺序访问对象，则发生死锁的可能性会降低。例如，如果两个并发事务获得 Supplier 表上的锁，然后获得 Part 表上的锁，则在其中一个事务完成之前，另一个事务被阻塞在 Supplier 表上。第一个事务提交或回滚后，第二个事务继续进行。不发生死锁。将存储过程用于所有的数据修改可以标准化访问对象的顺序。

(2) 避免事务中的用户交互
避免编写包含用户交互的事务，因为运行没有用户交互的批处理的速度要远远快于用户手动响应查询的速度，例如答复应用程序请求参数的提示。例如，如果事务正在等待用户输入，而用户去吃午餐了或者甚至回家过周末了，则用户将此事务挂起使之不能完成。这样将降低系统的吞吐量，因为事务持有的任何锁只有在事务提交或回滚时才会释放。即使不出现死锁的情况，访问同一资源的其它事务也会被阻塞，等待该事务完成。

(3) 保持事务简短并在一个批处理中
在同一数据库中并发执行多个需要长时间运行的事务时通常发生死锁。事务运行时间越长，其持有排它锁或更新锁的时间也就越长，从而堵塞了其它活动并可能导致死锁。
保持事务在一个批处理中，可以最小化事务的网络通信往返量，减少完成事务可能的延迟并释放锁。

(4) 使用低隔离级别
确定事务是否能在更低的隔离级别上运行。执行提交读允许事务读取另一个事务已读取（未修改）的数据，而不必等待第一个事务完成。使用较低的隔离级别（例如提交读）而不使用较高的隔离级别（例如可串行读）可以缩短持有共享锁的时间，从而降低了锁定争夺。

(5) 使用绑定连接
使用绑定连接使同一应用程序所打开的两个或多个连接可以相互合作。次级连接所获得的任何锁可以象由主连接获得的锁那样持有，反之亦然，因此不会相互阻塞

(6) SELECT语句加With(NoLock)提示
默认情况下SELECT语句会对查询到的资源加 S 锁(共享锁)，S锁与X锁(排他锁)不兼容；但加上 With(NoLock) 后，SELECT不对查询到的资源加锁(或者加 Sch-S 锁，Sch-S 锁可以与任何锁兼容)；从而可以是这两条 SQL 可以并发地访问同一资源。当然，此方法适合解决读与写并发死锁的情况，但加 With(NoLock) 可能会导致脏读。



#### 8.优化锁方面的建议

* 尽量使用较低的隔离级别。
* 精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会。
* 选择合理的事务大小，小事务发生锁冲突的几率也更小。
* 给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。
* 不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会。
* 尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。
* 不要申请超过实际需要的锁级别。
* 除非必须，查询时不要显示加锁。 MySQL 的 MVCC 可以实现事务中的查询不用加锁，优化事务性能；MVCC 只在 COMMITTED READ（读提交）和 REPEATABLE READ（可重复读）两种隔离级别下工作。
* 对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。



--------------



### 三、事务相关
#### 1.什么是事务

事务是**一系列的数据库操作，是数据库应用的基本单位**。MySQL 事务主要用于处理操作量大，复杂度高的数据。



#### 2.事务的特性

在 MySQL 中只有 InnDB 引擎支持事务，它的四个特性如下：
* 原子性（Atomic）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位；
* 一致性（Consistency）：事务的执行使得数据库从一种正确状态转化为另一种正确状态，事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到；
* 隔离性（Isolation）：在事务正确提交之前，不允许把该事务对数据的任何改变提供给其他事务，同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账；
* 持久性（Durability）：事务提交后，其结果永久保存在数据库中。



#### 3.事务的并发问题

1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

**幻读和不可重复读的区别？**

* 不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）。
* 幻读的重点在于新增或者删除：在同一事务中，同样的条件，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）。



#### 4.MySQL 中有几种事务隔离级别

四种，如下表
事务隔离级别|脏读|不可重复读|幻读
---|---|---
读未提交（read-uncommitted）|是|是|是
不可重复度（read-commited）|否|是|是
可重复读（repeatable-read）|否|否|是
串行化（serializable）|否|否|否

mysql 默认的事务隔离级别为 repeatable-read



#### 5.MVCC 是什么？

MVCC 是多版本并发控制（Multi-Version Concurrency Control）的简称，是用来解决事务中排他锁的使用导致读操作等待的。在四种隔离级别中，不可重复读和可重复读是使用了 MVCC 的，而串行化是使用了表级锁，读未提交好像什么都没实现。

InnoDB 的 MVCC 是通过在每行记录后面保存两个隐藏的列（实际上是三个，分别是DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID，但是为了记忆方便我们还是认为是两个）来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动新增，事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较。



#### 6.快照度和当前读

快照读：读取的是快照版本，也就是历史版本
当前读：读取的是最新版本
普通的SELECT就是快照读，而UPDATE、DELETE、INSERT、SELECT ...  LOCK IN SHARE MODE、SELECT ... FOR UPDATE是当前读。



#### 7.一致性非锁定读和锁定读

**锁定读**
在一个事务中，标准的SELECT语句是不会加锁，但是有两种情况例外。SELECT ... LOCK IN SHARE MODE 和 SELECT ... FOR UPDATE。
`SELECT ... LOCK IN SHARE MODE`给记录假设共享锁，这样一来的话，其它事务只能读不能修改，直到当前事务提交。`SELECT ... FOR UPDATE`给索引记录加锁，这种情况下跟UPDATE的加锁情况是一样的。

**一致性非锁定读**
　　consistent read （一致性读），InnoDB 用多版本来提供查询数据库在某个时间点的快照。如果隔离级别是 REPEATABLE READ，那么在同一个事务中的所有一致性读都读的是事务中第一个这样的读读到的快照(官方原文-"If the transaction isolation level is REPEATABLE_READ(the default level), all consistent reads within the same transaction read the snapshot established by the first such read in that transaction. You can get a fresher snapshot for you queries by commiting the current transaction and after that issuing new queries.")；如果是 READ COMMITTED，那么一个事务中的每一个一致性读都会读到它自己刷新的快照版本（官方原文-"With 'READ_COMMITTED' isolation level, each consistent read within a transaction sets and reads its own fresh snapshot"）。Consistent read（一致性读）是 READ COMMITTED 和 REPEATABLE READ 隔离级别下普通 SELECT 语句默认的模式。一致性读不会给它所访问的表加任何形式的锁，因此其它事务可以同时并发的修改它们。



#### 8.REPEATABLE READ（可重读）隔离级别下 MVCC 如何工作

* SELECT：InnoDB 会根据以下条件检查每一行记录：第一，InnoDB 只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行要么是在开始事务之前已经存在要么是事务自身插入或者修改过的。第二，行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除。
* INSERT：InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。
* DELETE：InnoDB 为删除的每一行保存当前系统版本号作为行删除标识。
* UPDATE：InnoDB 为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识。
这两个版本号，使大多数操作都不用加锁。它不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。



--------
### 一些问题
#### 1.不可重复读不也实现了 MVCC ？和可重复读有什么不同呢？

