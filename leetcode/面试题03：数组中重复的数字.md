### 面试题3：数组中重复的数字

**原题链接**：

[剑指 Offer 03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

**难度**：

简单

**题目**：

在一个长度为n的数组里的所有数字都在 `0~n-1`的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组 {2,3,1,0,2,5,3} ，那么对应的输出是重复的数字2或者3。

**思路**：

首先思考测试实例，特殊的有长度为0的数组，长度为1的数组。题目中的说法"输出的是2或者3"，且范围为`0~n-1`，显然不需要把所有重复的值都输出，因此我们可以让不存在重复值时输出-1，碰到相同元素即输出。然后思考解决方法。
可以借助HashMap，按顺序扫描数组里的元素，然后判断是否HashMap中是否存在该元素。由于HashMap使用的是哈希值，因此时间复杂度为O(n)，空间复杂度为O(n)。

```java
	public int duplicatedNumber(int[] nums) {
		
		if(nums.length == 0 ||nums.length==1) {
			return -1;
		}
		
		Map<Integer, Integer> map = new HashMap<>();
		
		for(int i : nums) {
			if(map.containsKey(i)) {
				return i;
			}
			map.put(i, 1);
		}
		
		return -1;
	}
```

再仔细一看题目，发现题目限定了n个数字且数字都在`0~n-1`范围内，那么可以使用另一个方法。将值为i的元素与下标i的元素进行比较，如果相同，则存在相同元素，否则将值为i的元素与下标为i的元素进行交换，同时便利数组，直到最后一个元素。

```java
	public int duplicatedNumber(int[] nums) {
		
		if(nums.length == 0 || nums.length == 1) {
			return -1;
		}
		
		for(int i = 0; i < nums.length; i++) {
			while(i!=nums[i]) {
				if(nums[i] == nums[nums[i]]) {
					return nums[i];
				}
				swap(i, nums);
			}
		}
		
		return -1;
	}
	
	public void swap(int i, int[] nums) {
		int temp = nums[i];
		nums[i] = nums[temp];
		nums[temp] = temp;
	}
```
